<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="application/json; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="data:,">
    <link rel="icon"
        href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVQI12P4//8/AAX+Av7czFnnAAAAAElFTkSuQmCC">
    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="{{ url_for('static', filename='js/script.js') }}"></script> -->

    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="script.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <title>Water Irrigation Schedule</title>
</head>

<body>
    <div class="container-fluid mt-3">
        <div id="root"></div>
    </div>
    <div>/%jsondata/%</div>
    <script>

        // channels 
        // c=0 -> col=0,8,16,24,32,40,48
        // c=1 -> col=1,9,17,25,33,41,49
        // c=2 -> col=2,10,18,26,34,42,50
        // c=3 -> col=3,11,19,27,35,43,51
        // c=4 -> col=4,12,20,28,36,44,52
        // c=5 -> col=5,13,21,29,37,45,53
        // c=6 -> col=6,14,22,30,38,46,54
        // c=7 -> col=7,15,23,31,39,47,55
        // d=0 -> col=0,1,2,3,4,5,6,7
        // d=1 -> col=8,9,10,11,12,13,14,15
        // d=2 -> col=16,17,18,19,20,21,22,23
        // d=3 -> col=24,25,26,27,28,29,30,31
        // d=4 -> col=32,33,34,35,36,37,38,39
        // d=5 -> col=40,41,42,43,44,45,46,47
        // d=6 -> col=48,49,50,51,52,53,54,55
        // p=0,1,2,3 -> 4 available periods
        // o=0,1 -> on,off channels

        // need to handle timerSetData between pages and submit. also handle illegal timersetdata i.e. on>off and remove empty timersetdata and a way to delete/clear data/all data w/ confirm button

        // myVar = myFunc({{ jsondata| tojson}})
        // function myFunc(vars) {
        //     console.log("myFunc" + vars)
        //     return vars
        // }
        // const myVar = {
        //     "timerSetData": {
        //         "c1d0p0o0": "04:00",
        //         "c1d0p0o1": "05:00",
        //         "c1d0p1o0": "07:00",
        //         "c1d0p1o1": "08:00",
        //         "c1d0p2o0": "19:00",
        //         "c1d1p0o0": "06:00",
        //         "c1d1p0o1": "08:00",
        //         "c1d1p1o0": "04:00",
        //         "c1d1p1o1": "05:00",
        //         "c2d1p0o0": "04:00",
        //         "c2d1p0o1": "05:00",
        //         "c3d2p0o0": "05:00",
        //         "c3d2p0o1": "06:00",
        //         "c3d2p1o0": "12:00",
        //         "c3d2p1o1": "13:00",
        //         "c1d0p2o1": "20:00"
        //     }
        // }
        // const myVar = {
        //     "timerSetData": {}
        // }
            const myVar = %jsondata%
            console.log(myVar)
        // let myVar={}
        // fetch("/getdata")
        // .then(response=>{if(!response.ok) throw new Error("Network response was not ok");return response.json()})
        // .then(data=>{console.log(data);console.log("came from params5.json"); myVar = data}).catch(error=>console.error('Fetch error:', error))
        
        // let myVar1 = JSON.parse("\%jsondata\%")
        // console.log()

        let selectedChannel = "1"
        let timerSetData = myVar.timerSetData   // copy reference.to clone, use structuredClone() or in the past JSON.parse(JSON.stringify())
        let localTimerSetData = { ...myVar.timerSetData }//structuredClone(myVar.timerSetData)

        function createNavBar() {

            const body = document.querySelector("body")
            // const nav = document.createElement("nav")
            // nav.classList.add("navbar", "navbar-expand-sm", "bg-dark", "navbar-dark")
            const nav = '<nav class="navbar navbar-expand-sm bg-dark navbar-dark">  \
        <div class="container-fluid">   \
            <a href="#" class="navbar-brand">   \
                <!-- <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc.<path d="M512 32c0 113.6-84.6 207.5-194.2 222c-7.1-53.4-30.6-101.6-65.3-139.3C290.8 46.3 364 0 448 0h32c17.7 0 32 14.3 32 32zM0 96C0 78.3 14.3 64 32 64H64c123.7 0 224 100.3 224 224v32V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V320C100.3 320 0 219.7 0 96z"/></svg> -->   \
                <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M192 512C86 512 0 426 0 320C0 228.8 130.2 57.7 166.6 11.7C172.6 4.2 181.5 0 191.1 0h1.8c9.6 0 18.5 4.2 24.5 11.7C253.8 57.7 384 228.8 384 320c0 106-86 192-192 192zM96 336c0-8.8-7.2-16-16-16s-16 7.2-16 16c0 61.9 50.1 112 112 112c8.8 0 16-7.2 16-16s-7.2-16-16-16c-44.2 0-80-35.8-80-80z"/></svg>   \
            </a>    \
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#collapsibleNavbar"> \
                <span class="navbar-toggler-icon"></span>   \
            </button>   \
            <div class="collapse navbar-collapse" id="collapsibleNavbar">   \
                <ul class="navbar-nav"> \
                    <li class="nav-item"><a class="nav-link active" \
                            onclick="onNavigate(\'/\'); return false;">Raw Summary</a></li>   \
                    <li class="nav-item"><a class="nav-link"    \
                            onclick="onNavigate(\'/schedule\'); return false;">Schedule</a></li>  \
                    <li class="nav-item"><a class="nav-link"    \
                            onclick="onNavigate(\'/timerset\'); return false;">Timer Set</a></li> \
                    <li class="nav-item"><a class="nav-link"    \
                        onclick="onNavigate(\'/testrelays\'); return false;">Test Relays</a></li> \
                    <li class="nav-item"><a class="nav-link"    \
                        onclick="onNavigate(\'/description\'); return false;">Description</a> \
                    <li class="nav-item"><a class="nav-link"    \
                        onclick="onNavigate(\'/help\'); return false;">Help</a>   \
                </ul>   \
            </div>  \
            <div class="clock navbar-text"> \
                <!-- <h1>NTP Time Display</h1> -->  \
                <!-- <p>Time from NTP server:  -->  \
                    <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><style>svg{fill:#ffffff}</style><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg>    \
                    <span class="ntp-time ">Loading...</span>   \
                <!-- </p> -->   \
            </div>  \
        </div>  \
    </nav>'
            

            body.insertAdjacentHTML("afterbegin",nav)

            const btns = document.querySelectorAll("nav .navbar-nav .nav-link")
            btns.forEach((btn => btn.addEventListener("click", function() {
                btns.forEach(btn => btn.classList.remove("active"))
                this.classList.add("active")
            })))

        }

        // because ESP32 %placeholder%
        function modulo(a,b) {
            return a % b
        }

        function createTimerSetRawSummary(timerSetData) {
            console.log("create summary")
            const summaryTopContainer = document.createElement("div")
            summaryTopContainer.classList.add("container")

            const gridContainer = document.createElement("div")
            gridContainer.classList.add("grid-container-top")

            const gridChannels = document.createElement("div")
            gridChannels.classList.add("grid-channels")
            gridContainer.appendChild(gridChannels)

            for(let i = 0; i < 56; i++) {
                const c = modulo(i, 8) + 1

                const gridItem = document.createElement("div")
                gridItem.classList.add("col" + i, "grid-item")
                gridItem.innerHTML = c
                gridChannels.appendChild(gridItem)
            }

            const gridDow = document.createElement("div")
            gridDow.classList.add("grid-dow")
            gridContainer.appendChild(gridDow)

            const dow = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
            dow.forEach((d, i) => {
                const gridItem = document.createElement("div")
                gridItem.classList.add("col" + i, "grid-item")
                gridItem.innerHTML = d
                gridDow.appendChild(gridItem)
            })

            const grid = document.createElement("div")
            grid.classList.add("grid-container")
            gridContainer.appendChild(grid)

            for (let c = 0; c < 56; c++) {
                for (let r = 0; r < 8; r++) {
                    const gridItem = document.createElement("div")
                    gridItem.classList.add("grid-item", "row" + r, "col" + c)
                    grid.appendChild(gridItem)
                    const channel = modulo(c, 8) + 1

                    const dow = Math.floor(c / 8)
                    const period = Math.floor(r / 2)
                    const onoff = modulo(r, 2)
                    const pattern = "c" + channel + "d" + dow + "p" + period + "o" + onoff
                    
                    if(timerSetData[pattern]) gridItem.innerHTML = timerSetData[pattern]
                }
            }

            const explanationDiv = document.createElement("div")
            const explanation = document.createElement("div")
            explanation.classList.add("summary-notes")
            explanation.innerHTML = '<h6><b>Explanation</b></h6>\
                                <p>first row is days of week</p>\
                                <p>second row is channel numbers</p>\
                                <p>subsequent rows are intervals 1 to 4, start and stop times</p>'
            explanationDiv.appendChild(explanation)

            summaryTopContainer.appendChild(gridContainer)
            summaryTopContainer.appendChild(explanationDiv)

            return summaryTopContainer
        }

        function createTimerSetDivTabs(timerSetData) {
            const tabContainer = document.createElement("ul")
            tabContainer.classList.add("nav","nav-tabs")
            for(let i = 0; i < 8; i++) {
                const tabItem = document.createElement("li")
                // tabItem.classList.add("nav-item", "c" + (i+1) + "on")
                const tabLink = document.createElement("a")
                tabLink.classList.add("nav-link")
                if (i == 0) tabLink.classList.add("active")
                tabLink.innerHTML = "" + (i+1)
                tabLink.addEventListener('click', function(){
                    document.querySelectorAll(".nav-tabs .nav-link").forEach(tab => tab.classList.remove("active"))
                    this.classList.add("active")
                    selectedChannel = this.innerHTML
                    // change input name to reference channel number
                    let inputList = document.querySelectorAll(".timerset-data input")
                    inputList.forEach(input => {
                        input.name = input.name.replace(/c\d+d/, 'c' + selectedChannel + 'd')
                        input.classList.value = input.classList.value.replace(/c\d+d/g, 'c' + selectedChannel + 'd')
                        console.log(input.classList)
                    })
                    // change input names to reference to selectedChannel
                    // once selected, load values from timerSetData object

                    inputList.forEach((input) => {
                        try {
                            input.value = localTimerSetData[input.name]
                        } catch (error) {

                        }
                    })

                    let inputDivList = document.querySelectorAll(".timerset-data .grid-item")
                    inputDivList.forEach(div => {
                        div.classList.value = div.classList.value.replace(/c\d+d/g, 'c' + selectedChannel + 'd')
                    })

// start validity highlight
                    // highlight input errors. reset after switching page
                    inputList.forEach(el => {
                        el.classList.remove("is-invalid")
                        el.classList.remove("is-valid")
                    }) 
                    inputList.forEach((self) => {
                        const prefix = self.name.substring(0,self.name.length-2)
                        const inputs = document.querySelectorAll(`input.${prefix}`)
                        if(inputs[0].value === '' || inputs[1].value === '') {
                            inputs.forEach(input=>input.classList.remove("is-valid","is-invalid"))
                        } else {
                            if(inputs[0].value < inputs[1].value) {
                                inputs.forEach(input=>{
                                    input.classList.remove("is-invalid")
                                    input.classList.add("is-valid")
                                })
                            } else {
                                inputs.forEach(input=>{
                                    input.classList.add("is-invalid")
                                    input.classList.remove("is-valid")
                                })
                            }
                        }
                     })

    
                    // // from chatgpt; off all colors
                    // document.querySelectorAll(".timerset2-container .timerset-dow .grid-item, \
                    // .timerset2-container .timerset-start-stop .grid-item, \
                    // .timerset2-container .timerset-control-label .grid-item, \
                    // .timerset2-container .timerset-submit-btn.grid-item").forEach((el) => {
                    //     let classes = el.classList
                    //     for (let i = 0; i < classes.length; i++) {
                    //         if(/^c[1-8]+on$/.test(classes[i])) {
                    //             classes.remove(classes[i])
                    //         }                  
                    //      }
                    //      classes.add("c" + (i+1) + "on")
                    // })

            
                })
                tabItem.appendChild(tabLink)
                tabContainer.appendChild(tabItem)
            }
            const tabDivLabel = document.createElement("div")
            tabDivLabel.classList.add("nav_tab_div_label")
            tabDivLabel.innerHTML = "Channel"
            tabContainer.insertAdjacentElement("afterbegin", tabDivLabel)

            return tabContainer

        }

        function createTimerSetForm(timerSetData) {
            // create container and insertBefore channel tabs and timerset2-container
            console.log("create timerset form")

            const container = document.createElement("div")
            container.classList.add("container")

            const titlecontainer = document.createElement("div")
            titlecontainer.innerHTML = "<h1>Timer Set</h1>"
            titlecontainer.classList.add("title")
            container.appendChild(titlecontainer)

            
            const timersetDivTabs = document.createElement("div")
            timersetDivTabs.classList.add("timerset-div-tabs")
            timersetDivTabs.appendChild(createTimerSetDivTabs(timerSetData))
            container.appendChild(timersetDivTabs)

            const timersetContainer = document.createElement("div")
            timersetContainer.classList.add("timerset-container")
            container.appendChild(timersetContainer)

            const timersetForm = document.createElement("form")
            timersetForm.classList.add("form-group")
            timersetContainer.appendChild(timersetForm)

            const timersetControlLabel = document.createElement("div")
            timersetControlLabel.classList.add("timerset-control-label")
            timersetForm.appendChild(timersetControlLabel)

            const timersetDoW = document.createElement("div")
            timersetDoW.classList.add("timerset-dow")
            timersetForm.appendChild(timersetDoW)

            const timersetStartStop = document.createElement("div")
            timersetStartStop.classList.add("timerset-start-stop")
            timersetForm.appendChild(timersetStartStop)

            const timersetData = document.createElement("div")
            timersetData.classList.add("timerset-data")
            timersetForm.appendChild(timersetData)

            const gridItem = document.createElement("div")
            gridItem.classList.add("grid-item")
            timersetControlLabel.appendChild(gridItem)
            gridItem.innerHTML = "Control"

            const timersetSubmitBtn = document.createElement("div")
            timersetSubmitBtn.classList.add("timerset-submit-btn", "grid-item")
            timersetForm.appendChild(timersetSubmitBtn)

            const dow = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
            dow.forEach((d, i) => {
                const gridItem = document.createElement("div")
                gridItem.classList.add("col" + i, "grid-item")
                gridItem.innerHTML = d
                timersetDoW.appendChild(gridItem)
            })

            for (let i = 0; i < 8; i++) {
                const div = document.createElement("div")
                timersetStartStop.appendChild(div)
                div.classList.add("row" + (i), "grid-item")
                const p = Math.floor(i/2) + 1
                if (modulo(i,2) == 0) div.innerHTML = "Start Period " + p
                if (modulo(i,2) == 1) div.innerHTML = "Stop Period " + p
            }

            for (let c = 0; c < 7; c++) {
                for (let r = 0; r < 8; r++) {
                    const gridItem = document.createElement("div")
                    gridItem.classList.add("col" + c, "row" + r, "grid-item")

                    timersetData.appendChild(gridItem)

                    const input = document.createElement("input")
                    input.classList.add("input-sm", "form-control")
                    gridItem.appendChild(input)
                    input.type = "time"
                    let _c = selectedChannel
                    let _d = c
                    let _p = Math.floor(r / 2)
                    let _o = modulo(r, 2)
                    if ((_o == 0)) {
                        input.name = "c" + _c + "d" + _d + "p" + _p + "o0"
                        input.classList.add("c" + _c + "d" + _d + "p" + _p + "o0")
                        gridItem.classList.add("c" + _c + "d" + _d + "p" + _p + "o0")
                    } else {
                        input.name = "c" + _c + "d" + _d + "p" + _p + "o1"
                        input.classList.add("c" + _c + "d" + _d + "p" + _p + "o1")
                        gridItem.classList.add("c" + _c + "d" + _d + "p" + _p + "o1")
                    }
                    input.classList.add("c" + _c + "d" + _d + "p" + _p)
                    gridItem.classList.add("c" + _c + "d" + _d + "p" + _p)

                    // should save in localStorage first. otherwise, updateSchedule (when switching tabs) will show changed values.
                    // what is desirable is that schedule only shows submitted values

                    input.addEventListener('change', function() {
                        const prefix = this.name.substring(0,this.name.length-2)
                        const inputs = document.querySelectorAll(`input.${prefix}`)
                        if(inputs[0].value === '' || inputs[1].value === '') {
                            inputs.forEach(input=>input.classList.remove("is-valid","is-invalid"))
                        } else {
                            if(inputs[0].value < inputs[1].value) {
                                inputs.forEach(input=>{
                                    input.classList.remove("is-invalid")
                                    input.classList.add("is-valid")
                                })
                            } else {
                                inputs.forEach(input=>{
                                    input.classList.add("is-invalid")
                                    input.classList.remove("is-valid")
                                })
                            }
                        }
                        if(this.value!=='') {
                            localTimerSetData[this.name] = this.value
                        } else {
                            delete localTimerSetData[this.name]
                        }
                    })
                    // end change event

                    // initialization - fill relevant input with timerset data (check initChannelButtons())
                    try {
                        input.value = timerSetData[input.name]
                        // console.log(timerSetData)
                        checkInputValidity(timerSetData)
                    } catch (error) {

                    }
                }
            }

            const submitElement = document.createElement("button")
            submitElement.name = "submitBtn"
            submitElement.classList.add("submitBtn", "btn", "btn-light")
            submitElement.innerHTML = "Enter"

            timersetSubmitBtn.appendChild(submitElement)

            submitElement.onclick = (e) => postData(e)

            function postData(e) {
                // alert("clicked button, channel=" + selectedChannel)
                e.preventDefault()

                // check validity of input. if ok, post, else, prompt for correction

                if(!checkInputValidity(localTimerSetData)) return

                // if valid, should copy localTimerSetData (which keeps local data) into timerSetData and posted to server, instead of myVar.timerSetData

                timerSetData =  { ...localTimerSetData }

                fetch("/timerset", { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ "timerSetData": timerSetData }) // should submit localStorage values
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log("post timerset")
                        console.log(data); 
                        myVar.timerSetData = data.timerSetData;
                        localTimerSetData = { ...myVar.timerSetData }//structuredClone(myVar.timerSetData) or Object.assign({},myVar.timerSetData)
                        timerSetData = myVar.timerSetData
                        ntptime = data.ntptime
                    })
                    .catch(error => console.error(error))
                
            }
            // compliments of chatgpt
            function checkInputValidity(timerSetData) {
                console.log(timerSetData)

                let valid=1
                // document.querySelectorAll(".timerset-data .grid-item").forEach(el => el.classList.remove("highlight"))

                const groupEntries = {}
                let prefixes = [] //"c1d0p1"
                // Group entries by their prefixes
                Object.keys(timerSetData).forEach(key => {
                    const keyPrefix = key.match(/^c\d+d\d+p\d+/)[0]
                    if(!groupEntries[keyPrefix]) {
                        groupEntries[keyPrefix] = []
                    }
                    groupEntries[keyPrefix].push({key, value: timerSetData[key]})
                    prefixes.push(keyPrefix)
                })

                prefixes = prefixes.filter((v,i,self)=>i==self.indexOf(v))
                console.log(prefixes)

                prefixes.forEach(prefix => {
                    const [c,d,p,o] = prefix.split(/c(\d+)d(\d+)p(\d+)/).filter(n=>n)

                    const entries = groupEntries[prefix]
                    if(!entries) {
                        console.log(`No entries with prefix "${prefix}" found`)
                        return
                    }

                    if(entries.length >= 2) {
                        for (let i = 0; i < entries.length - 1; i++) {
                            for (let j = i + 1; j < entries.length; j++) {
                                const entry1 = entries[i];
                                const entry2 = entries[j];
 
                                if(entry1.value < entry2.value) return false
                            }
                        }
                    } else {
                        console.log(`Not enough matching entries with prefix "${prefix}"`)
                    }
                })
                return true
            }

            return container
        }

        function updateSchedule(timerSetData) {
            console.log("update schedule")
            console.log(timerSetData)
            const keys = Object.keys(timerSetData)
            const object = timerSetData

            // from chatgpt; off all colors
            document.querySelectorAll(".schedule-container .schedule-data .grid-item").forEach((el) => {
                let classes = el.classList
                for (let i = 0; i < classes.length; i++) {
                    if(/^c[1-8]+on$/.test(classes[i])) {
                        classes.remove(classes[i])
                    }                  
                }
            })

            for (let i = 0; i < keys.length; i+=2) {
                const on = timerSetData[keys[i]];
                const off = timerSetData[keys[i+1]];
                const [c,d,p,o] = keys[i].split(/c(\d+)d(\d+)p(\d+)o(\d+)/).filter(n=>n)
                const col = (+d-0)*8+ +c-1
                if(on<off) {
                    console.log("on<off")
                    const [on_hr,on_min] = on.split(":")
                    const [off_hr,off_min] = off.split(":")
                    const rowStart = on_hr * 2 + (on_min > 0 ? 1 : 0)   // 30 min interval
                    const rowStop = off_hr * 2 + (off_min > 0 ? 1 : 0)   // 30 min interval
                    for (let row = rowStart; row < rowStop; row++) {
                        console.log("update class: row=" + row + ",col=" + col)
                        // doesn't work when div.schedule-container not mountee
                        // console.log("update:" + row +"," + col + "," + on + "," + off)
                        document.querySelector(".schedule-container .row"+row+".col"+col).classList.remove("coff")
                        document.querySelector(".schedule-container .row"+row+".col"+col).classList.add("c"+c+"on")
                    }
                }
            }
        }

        function createSchedule(timerSetData) {
            console.log("create schedule")

            const container = document.createElement("div")
            container.classList.add("container")

            const titlecontainer = document.createElement("div")
            titlecontainer.innerHTML = "<h1>Schedule</h1>"
            titlecontainer.classList.add("title")
            container.appendChild(titlecontainer)

            const schedulecontainer = document.createElement("div")
            schedulecontainer.classList.add("schedule-container")
            container.appendChild(schedulecontainer)

            const scheduleTimeLabel = document.createElement("div")
            scheduleTimeLabel.classList.add("schedule-time-label")
            schedulecontainer.appendChild(scheduleTimeLabel)

            const scheduleDoW = document.createElement("div")
            scheduleDoW.classList.add("schedule-dow")
            schedulecontainer.appendChild(scheduleDoW)

            const scheduleTime = document.createElement("div")
            scheduleTime.classList.add("schedule-time")
            schedulecontainer.appendChild(scheduleTime)

            const scheduleData = document.createElement("div")
            scheduleData.classList.add("schedule-data")
            schedulecontainer.appendChild(scheduleData)

            const gridItem = document.createElement("div")
            gridItem.classList.add("grid-item")
            scheduleTimeLabel.appendChild(gridItem)
            gridItem.innerHTML = "Time"

            const dow = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
            dow.forEach((d, i) => {
                const gridItem = document.createElement("div")
                gridItem.classList.add("col" + i, "grid-item")
                gridItem.innerHTML = d
                scheduleDoW.appendChild(gridItem)
            })

            for (let t = 0; t < 48; t++) {
                const timeStr = Math.floor(t / 2).toLocaleString('en-US', { minimumIntegerDigits: 2, useGrouping: false }) + ":" + (modulo(t,2) == 0 ? "00" : "30")
                const gridItem = document.createElement("div")
                gridItem.classList.add("row" + t, "grid-item")
                gridItem.innerHTML = timeStr
                scheduleTime.appendChild(gridItem)
            }
            try{
            const keys = Object.keys(timerSetData)
            const timerSetDataLength = keys.length
            } catch (error) {

            }

            for (let c = 0; c < 56; c++) {
                const channel = modulo(c, 8) + 1
                const dow = Math.floor(c / 8)
                const pattern = "c" + channel + "d" + dow

                try {
                filteredData = filterData(timerSetData, pattern)
                const filteredDataKeys = Object.keys(filteredData)
                const filteredDataLength = Object.keys(filteredData).length
                } catch (error) {

                }
                // console.log(pattern + ", " + Object.keys(filteredData).length)
                for (let r = 0; r < 48; r++) {
                    const gridItem = document.createElement("div")
                    gridItem.classList.add("grid-item")
                    gridItem.classList.add("row" + r, "col" + c)
                    gridItem.classList.add("coff")
                    // gridItem.on // wanted to on hover, show timer setting ?
                    // gridItem.innerHTML = channel
                    scheduleData.appendChild(gridItem)
                    try {
                        if (filteredDataLength > 0) {
                            for (let i = 0; i < filteredDataLength; i = i + 2) {
                                const on = filteredData[filteredDataKeys[i]]
                                const off = filteredData[filteredDataKeys[i + 1]]
                                const timeStr = Math.floor(r / 2).toLocaleString('en-US', {
                                    minimumIntegerDigits: 2, useGrouping: false
                                }) + ":" + (modulo(r, 2) == 0 ? "00" : "30")

                                if (timeStr >= on && timeStr < off) {
                                    gridItem.classList.add("c" + channel + "on")
                                    gridItem.classList.remove("coff")
                                }
                            }
                        }
                    } catch (error) {
                        
                    }
                }
            }

            function filterData(inputData, substringToMatch) {
                const filteredEntries = Object.entries(myVar.timerSetData).filter(([key, _]) => key.includes(substringToMatch))
                const filteredData = Object.fromEntries(filteredEntries)
                return filteredData
            }
            return container
        }

        function createTestRelays() {
            // relay duration timer
            let timers = []

            console.log("createTestRelays")
            const container = document.createElement("div")
            container.classList.add("container")

            const titlecontainer = document.createElement("div")
            titlecontainer.innerHTML = "<h1>Test Relays</h1>"
            titlecontainer.classList.add("title")
            container.appendChild(titlecontainer)

            resetBtnDiv = document.createElement("div")
            resetBtnDiv.classList.add("resetBtnDiv")
            // pageResetBtnDiv.innerHTML = "On/Off"
            container.appendChild(resetBtnDiv)
   
            const resetBtn = document.createElement("button")
            resetBtn.name = "resetBtn"
            resetBtn.classList.add("resetBtn", "btn", "btn-danger")
            resetBtn.innerHTML = "Reset"
            resetBtn.addEventListener("click", () => {
                    document.querySelectorAll(".testrelays input").forEach((el) => {
                        el.checked = false
                    })
                    document.querySelectorAll(".testrelays .duration").forEach((el) => {
                        el.innerHTML = "0 seconds"
                    })
                    for(let i = 0; i < timers.length; i++) {
                        clearInterval(timers[i])
                    }

                    // should postdata and broadcast to other devices
                    fetch("/resetrelays")
                    .then(response=>response.json())
                    .then(data=>console.log(data))
                    .catch(error=>{console.error(error)})
            })
            resetBtnDiv.appendChild(resetBtn)



            const relayBtnContainer = document.createElement("div")
            relayBtnContainer.classList.add("container","testrelays")
            container.appendChild(relayBtnContainer)

            for (let i = 0; i < 8; i++) {
                const relayBtnRow = document.createElement("div")
                relayBtnRow.classList.add("row")

                const colDiv1 = document.createElement("div")
                colDiv1.classList.add("col-sm-6")
                relayBtnRow.appendChild(colDiv1)
                const colDiv2 = document.createElement("div")
                colDiv2.classList.add("col-sm-3")
                relayBtnRow.appendChild(colDiv2)
                const colDiv3 = document.createElement("div")
                colDiv3.classList.add("col-sm-3")
                relayBtnRow.appendChild(colDiv3)
                relayBtnContainer.appendChild(relayBtnRow)
                

                const c = i + 1

                const label = document.createElement("h6")
                label.innerHTML = "Channel " + c
                colDiv1.appendChild(label)


                const relayInput = document.createElement("input")
                relayInput.setAttribute("type","checkbox")
                // if (c == 1) relayInput.checked = true

                const relaySpan = document.createElement("span")
                relaySpan.classList.add("slider","round")

                const relaySwitch = document.createElement("div")
                relaySwitch.classList.add("switch","sw"+c)

                const relayLabel = document.createElement("label")
                relayLabel.appendChild(relayInput)
                // relayLabel.classList.add("switch")
                relayLabel.appendChild(relaySpan)


                relayInput.addEventListener("click", function() {
                    if(this.checked)
                        state = 1
                    else 
                        state = 0
                    actuateRelay(c, state)

                    if(this.checked) {
                            timers[i] = setInterval(()=> {
                            const d = document.querySelector(".c" + c)
                            let t = parseInt(d.innerHTML.split(" ")[0])
                            d.innerHTML = t + 1 + " seconds"
                        }, 1000)
                    } else {
                        clearInterval(timers[i])
                        const d = document.querySelector(".c" + c)
                        d.innerHTML = "0 seconds"
                    }
                })

                relaySwitch.appendChild(relayLabel)
                colDiv2.appendChild(relaySwitch)

                const relayDuration = document.createElement("div")
                relayDuration.classList.add("duration","c"+c)
                relayDuration.innerHTML = "0 seconds"

                colDiv3.appendChild(relayDuration)

            }
            return container
        }

        function actuateRelay(channel, state) {
            state == 1 ?
            console.log("Channel " + channel + " is activated!") :
            console.log("Channel " + channel + " is deactivated!")


// trigger digitalwrite to channel/gpio
           fetch("/actuaterelay", { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ "channel": channel, "state": state }) // should submit localStorage values
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(data); 
                        // myVar.timerSetData = data.jsondata.timerSetData;
                        // localTimerSetData = structuredClone(myVar.timerSetData)
                        // timerSetData = myVar.timerSetData
                        // mydata2 = data;
                        // populateScheduleData(timerSetData)
                        // updateSchedule(timerSetData)    // doesn't work when div.schedule-container not mounted
                        // ntptime = data.ntptime
                    })
                    .catch(error => console.error(error))
        }

        function createDescription() {
            const container = document.createElement("div")
            container.classList.add("container")

            const titlecontainer = document.createElement("div")
            titlecontainer.innerHTML = "<h1>Description</h1>"
            titlecontainer.classList.add("title")
            container.appendChild(titlecontainer)

            const descriptionArea = document.createElement("div")
            descriptionArea.classList.add("form-group")
            const label = document.createElement("label")
            label.setAttribute("for","notes")
            label.innerHTML = "Write your notes here:"
            const textArea = document.createElement("textarea")
            textArea.classList.add("form-control")
            textArea.rows = 16
            // textArea.maxLength = "5000"
            textArea.id = "notes"
            descriptionArea.appendChild(label)
            descriptionArea.appendChild(textArea)

            container.appendChild(descriptionArea)

            // <div class="form-group">
            // <label for="comment">Comment:</label>
            // <textarea class="form-control" rows="5" id="comment"></textarea>
            // </div> 

            const submitBtnDiv = document.createElement("div")
            submitBtnDiv.classList.add("timerset-submit-btn", "grid-item")
            container.appendChild(submitBtnDiv)

            const submitElement = document.createElement("button")
            submitElement.name = "submitBtn"
            submitElement.classList.add("submitBtn", "btn", "btn-light")
            submitElement.innerHTML = "Enter"

            submitBtnDiv.appendChild(submitElement)

            submitElement.onclick = (e) => postData(e)

            function postData(e) {
                // alert("clicked button, channel=" + selectedChannel)
                e.preventDefault()
                console.log("notes entered")

                notes = textArea.value
                console.log(notes)

                fetch("/description_notes", { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ "notes": notes }) // should submit localStorage values
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(data); 
                        // console.log(data.notes)
                        // textArea.value = data.notes
                    })
                    .catch(error => console.error(error))

            }

            fetch("/description_notes")
            .then(response => response.json())
            .then(data=> { 
                console.log(data)
                textArea.value = data.notes
            })
            .catch(error=> console.error(error))

            return container
        }

        function createHelp() {
            const container = document.createElement("div")
            container.classList.add("container")

            const titlecontainer = document.createElement("div")
            titlecontainer.innerHTML = "<h1>Help</h1>"
            titlecontainer.classList.add("title")
            container.appendChild(titlecontainer)

            const textArea = document.createElement("textarea")
            textArea.classList.add("form-control")
            textArea.rows = 16
            container.appendChild(textArea)

            textArea.value = "Type something....."
            textArea.readOnly = true
            textArea.disabled = true

            const textAreaDiv = document.createElement("div")
            textAreaDiv.classList.add("timerset-submit-btn", "grid-item")
            container.appendChild(textAreaDiv)

            const toggleReadOnly = document.createElement("button")
            toggleReadOnly.innerHTML = "Turn Edit On"
            toggleReadOnly.classList.add("btn", "btn-light")
            toggleReadOnly.addEventListener('click', ()=>{
                textArea.readOnly = !textArea.readOnly
                toggleReadOnly.innerHTML = textArea.readOnly==true?"Turn Edit On":"Turn Edit Off"
                textArea.disabled = textArea.readOnly==true?true:false
            })
            textAreaDiv.appendChild(toggleReadOnly)

            const saveEdit = document.createElement("button")
            saveEdit.innerHTML = "Save Edit"
            saveEdit.classList.add("btn", "btn-light")
            saveEdit.addEventListener('click', ()=>{
                console.log("save edit...")
                helptext = textArea.value
                fetch("/savehelptext", {
                    method: 'POST', 
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({"helptext":helptext})
                }).then(response=>response.json()).then(data=>console.log(data)).catch(error=>console.error(error))
            })
            textAreaDiv.appendChild(saveEdit)

            fetch("/savehelptext").then(response=>response.json()).then(data=>textArea.value=data.helptext).catch(error=>console.error(error))

            return container
        }

        let element1, element2, element3, element4, element5, element6

// start validity highlight

        function initialCheckInputValidity(self) {
            console.log("initialCheckInputValidity")
            const prefix = self.name.substring(0,self.name.length-2)
            const inputs = document.querySelectorAll(`input.${prefix}`)
            if(inputs[0].value === '' || inputs[1].value === '') {
                inputs.forEach(input=>input.classList.remove("is-valid","is-invalid"))
            } else {
                if(inputs[0].value < inputs[1].value) {
                    inputs.forEach(input=>{
                        input.classList.remove("is-invalid")
                        input.classList.add("is-valid")
                    })
                } else {
                    inputs.forEach(input=>{
                        input.classList.add("is-invalid")
                        input.classList.remove("is-valid")
                    })
                }
            }
        }

        function renderCheckForm() {
            let inputList = document.querySelectorAll(".timerset-data input")
            console.log("here")
            inputList.forEach(input => {
                initialCheckInputValidity(input)
            })
        }

        function init(i) {
            console.log(myVar.timerSetData)
            createNavBar()

            element1 = createTimerSetRawSummary(myVar.timerSetData)
            element2 = createSchedule(myVar.timerSetData)
            element3 = createTimerSetForm(myVar.timerSetData)
            element4 = createTestRelays()
            element5 = createDescription()
            element6 = createHelp()
        }

        function updateTime() {
            fetch('/get_time')
                .then(response => {
                    // console.log('Response:', response); 
                    return response.json()
                })
                .then(data => {
                    console.log('Data:', data.time)
                    if (data.time !== null) {
                        const ntpTime = new Date(data.time * 1000)
                        console.log(ntpTime.toLocaleString())
                        // const options = {weekday:"long",year:"numeric",mont}
                        document.querySelector('.ntp-time').textContent = ntpTime.toLocaleString('en-US', { weekday: "long", year: "numeric", month: "short", day: "numeric", hour12: false, hour: "numeric", minute: "numeric", second: "numeric" }) //ntpTime.toUTCString()
                        checkTimerEvent(ntpTime)
                    }
                }).catch(error => console.error(error))
        }

        function checkTimerEvent(ntpTime) {
            let dow = ntpTime.getDay() // ntpTime.getUTCDay()
            let timeNow = ntpTime.toLocaleString('en-US', { hour12: false, hour: "numeric", minute: "numeric" })
            let _timeNow = timeNow.split(":")
            let rowNow = _timeNow[0] * 2 + (_timeNow[1] > 0 ? 1 : 0)
            // console.log("dow=" + dow + ", timeNow=" + timeNow + ", rowNow=" + rowNow)
            let dowCol = dow * 8 // number of relays = 8
            for (let i = dowCol; i < dowCol + 8; i++) {
                try {
                    document.querySelector(".schedule-data .col" + i + ".row" + rowNow).innerHTML = dow
                } catch(error) {
                    // console.error(error)
                }
            }
        }


        init(0) // channel 1 first on load
        setInterval(updateTime, 3600 * 1000)


    </script>

    <script>

        const summary = element1
        const schedule = element2 // update schedule where necessary since form may have been resubmitted
        const timerset = element3
        const testrelays = element4
        const description = element5
        const help = element6

        const routes = { // these are window.location.pathname too
            '/': summary,
            '/schedule': schedule,
            '/timerset': timerset,
            '/testrelays': testrelays,
            '/description': description,
            '/help': help
        }

        const rootDiv = document.querySelector('#root')
        rootDiv.appendChild(routes['/'])

        function onNavigate(pathname) {
            window.history.pushState(
                {page:pathname}, {}, window.location.origin + pathname
            )
            if (rootDiv.hasChildNodes())
                rootDiv.removeChild(rootDiv.children[0])
            rootDiv.appendChild(routes[pathname])
            if(pathname === "/schedule") {
                try {
                    updateSchedule(myVar.timerSetData)
                } catch (error) {

                }
            }

            if(pathname === "/timerset") {
                renderCheckForm()
            }
        }

        window.onpopstate = (e) => {
            if (rootDiv.hasChildNodes())
                rootDiv.removeChild(rootDiv.children[0])
            
            rootDiv.appendChild(routes[window.location.pathname])
            if(e.state && e.state.page === "/schedule") {
                try {
                    updateSchedule(myVar.timerSetData)
                } catch (error) {

                }          
            }
            if(e.state && e.state.page === "/timerset") {
                try {
                    renderCheckForm()
                } catch (error) {

                }          
            }
        }

    </script>
</body>


</html>